import { ComponentArguments, Component } from '../components';
import { GenericFactory } from '../GenericFactory';
import { CommonElementArguments } from '../Common';

/**
 * The object coming from the CLI, used in the constructor
 */
export type ApplicationArguments = CommonElementArguments & {
  elements: ComponentArguments[],
  uuid: string,
  /**
   * When true, the Application destroys itself (including closing the Modal, Window or whatever)
   * This is only true after the Application has been rendered once - e.g.
   * it wouldn't be "true" in the constructor, only in the refresh function
   */
  should_exit: boolean,
  etype: string[]
}

/**
 * An application is a Window, Modal, or some other container of the interactive
 * UI elements. Everything inside the Application is generated by the CLI,
 * everything outside comes from the IDE.
 *
 * An application is created once in its lifetime, and thereafter only "refreshed"
 * using the refresh callback
 */
export abstract class Application {
  elements: Component[];
  uuid: string;
  _update: (d: any) => void;
  kill: () => void;

  destroy(): void { }

  constructor({
    elements,
    uuid,
    __componentFactory,
    _update,
    _kill
  }: ApplicationArguments) {
    this.elements = elements.map(c => __componentFactory.createInstance(c));
    this.uuid = uuid;
    this._update = _update;
    this.kill = _kill;
  }

  refresh({ should_exit, elements, __componentFactory, _kill }: ApplicationArguments) {
    this.kill = _kill;
    if (should_exit) {
      this.destroy();
    } else {
      this.elements = elements.map(c => __componentFactory.createInstance(c));
    }
  }
}

export type ApplicationConstructor = { new(ApplicationArguments: ApplicationArguments): Application }

/**
 * Alias to a GenericFactory capable of deserializing an Application
 */
export class ApplicationFactory extends GenericFactory<Application, ApplicationConstructor, ApplicationArguments> { }
